global:

  defaultRbacEnabled: true
  defaultClusterRole: permissive-network-cr
  defaultServiceAccountName: fed-kubeprom-serviceaccount
  podPriorityEnabled: true

  # PaaS Registry Selector 
  registry:
    docker:
      repoPath: "a4oprodaf.a4opacketcore.microsoft.com/rel_build_docker"

  # Prometheus metric scrape interval. Default value set to 30 seconds.
  metricsScrapeInterval: 30s

  # Environment variables
  envVars:
    fedType: "kube-prom"
    fedUniqueName: "default"

  # This enables creation of specific kargo-default-profile for fed-kube-prom 
  kargoProfileTag: "kubeprom"

  logging:
    enabled: false
    fluentd:
      buffer:
        bufferLimit: 512m  # Total buffer size. Maximum amount of buffer space each fluentd thread would use to keep logs. After this is exhaused, fluentd would start deleting oldest logs to make room for new logs.
        retryWait: 180s    # Interval(seconds) at which the buffer flush is retried in case of failure.
        maxRetries: 10     # Max number of retries to flush a buffer chunk. After this is exhausted, fluentd would delete the chunk.
    elastic:
      IP: ""
      Port: 9200
    enableAddlTargets: false
    addlTargets:
    - forward:
        name: fluentd
        host: ""
        port: 24224

  grafanaDatasource:
    enabled: true
    # If Grafana is enabled, please add a valid Grafana server URL as per the following guidelines.
    # If Grafana is deployed WITHOUT TLS: "http://[grafana-ip]:[grafana-port]" OR "http://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    # If Grafana is deployed WITH TLS: "https://[grafana-ip]:[grafana-port]" OR "https://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    url: ""
    prometheusinfo:
      url: "http://prometheus-k8s.fed-kube-prom:9099"

  #Generic password for all PaaS components
  adminPassword: ""

  vault:
    enabled: false
    hashicorpVault:
      enabled: true
    azureKeyVault:
      enabled: false

  # PaaS Monitoring Selector
  monitoring:
    prometheus:
      enabled: true

  # PaaS Service Mesh Selector
  mesh:
    istio:
      # set this value only if load balancer sharing key is configured
      ingressGwIP: ""
      ingressGwFQDN: "kubepromgrafana.com"

      # If specified this port will be used irresepective of TLS mode
      # If not specified, port 80 will be used if TLS is enabled, else port 443 will be used
      ingressGwPort: 3000

      # This controls use of TLS in GWs
      ingressGwTLS:
          enabled: true
          # Set the tls mode
            # SIMPLE --> to enable only TLS
            # MUTUAL --> to enable mTLS (default)
          mode: SIMPLE
          certManager:
            enabled: true
            certDuration: 10h
            renewBefore: 1h
            organization: affirmednetworks
            issuerName: affirmed-clusterissuer
          userProvided:
            enabled: false
            #Please refer to userguide documentation
            cacert: |-

            tlscrt: |-

            tlskey: |-

      ingressGwAdditionalServices:
        - ingressGwIP: ""
          ingressGwFQDN: "kubepromalertmanager.com"
          ingressGw: "kubepromalertmanager-ingress"
          ingressGwPort: 9093
          mtlsEnabled: false
          ingressGwTLS:
            enabled: true
            mode: SIMPLE
          serviceAnnotations:
            service.beta.kubernetes.io/azure-load-balancer-internal: "true"
            service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"
        - ingressGwIP: ""
          ingressGwFQDN: "kubeprom.com"
          ingressGw: "kubeprom-ingress"
          ingressGwPort: 9099
          mtlsEnabled: false
          ingressGwTLS:
            enabled: true
            mode: SIMPLE
          serviceAnnotations:
            service.beta.kubernetes.io/azure-load-balancer-internal: "true"
            service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"

      loadBalancerSharingKey: "kube_prom"
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"

pod-istio_gw:
  egressGateway:
    enabled: false

pod-kube_prom:
  service: {}
  prometheus:
    replicas: 2
    resources:
      limits:
        cpu: 1
        memory: 8Gi
      requests:
        cpu: 500m
        memory: 1Gi

    storage:
        # type can be local, remote or rook
        type: rook

        # To use storage class of fed-rook-ceph, Configure storageclass field with the storage class name that gets deployed with fed-rook-ceph.
        # default value is "rook-cephbp". To use any other storage provisioner provide name of your convienence.
        #storageClassName: cinder-class-k8s-prom
        storageClassName: rook-cephbp
        # if storage.type is set as rook, Configure storageclass and do not configure the below mentioned fields. When type is rook, provisioner and all the other
        # configuration parameters will be taken from storage class of fed-rook-ceph.
        # set provisioner as:
        # kubernetes.io/cinder for cinder storage
        # kubernetes.io/azure-disk for azureDisk
        # To provide any other custom storage, configure provisioner field and add related parameters under customParameters
        provisioner: kubernetes.io/cinder

        parameters:
          cinder:
            type: sannimbf300
            availability: nova
            fsType: ext4
          azureDisk:
            storageaccounttype: ""
            kind: ""
          #configure below customParameters to provide parameters for custom storage option, if the provisioner is none of the above.
          customParameters: {}

        #PersistentVolumes that are dynamically created by a StorageClass will have the reclaim policy specified in the reclaimPolicy field of the class, which can be either Delete or Retain
        reclaimPolicy: Delete
        allowVolumeExpansion: true

        resource:
          request: 50Gi # if external storage is enabled then resource request has to be configured as per user/customer requirement
    retention: 3d

  
  
  probesCheck:
    liveliness:
      failureThreshold: 120
      initialDelaySeconds: 30
      periodSeconds: 60
      successThreshold: 1
      timeoutSeconds: 5

    readiness:
      failureThreshold: 120
      initialDelaySeconds: 30
      periodSeconds: 60
      successThreshold: 1
      timeoutSeconds: 5


  alertmanager:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom alertmanager: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: permissive-network-cr
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: alertmanager-main
    replicas: 1

    config:
      global:
        resolve_timeout: 5m
      route:
        group_wait: 30s
        group_interval: 2m
        repeat_interval: 2m
        receiver: "null" #Provide receiver name to send alerts to, slackreceiver for slack, emailreceiver for email, postreceiver for HTTP POST
      receivers:
      - name: "null"
      - name: "postreceiver"
        webhook_configs:  #HTTP POST receiver
        - url: "http://XXXX"
          http_config:
            tls_config:
              insecure_skip_verify: true
      - name: "emailreceiver"
        email_configs:    #email receiver
        - to: "user1@example.com"
          from: "user2@example.com"
          smarthost: "XXXX:80"  #SMTP IP address along with port
          auth_username: "user@example.com" #SMTP authentication username and password
          auth_password: "password"
          require_tls: false
          headers: {Subject: "Alert from: {{ .CommonLabels.alertname }} "}
      - name: "slackreceiver"
        slack_configs:     #slack receiver
        - channel: "#channel_name"
          api_url: "http://XXXX"
          text: "summary: {{ .CommonAnnotations.summary }}\ndescription: {{ .CommonAnnotations.description }}"
          title: "Alert from: {{ .CommonLabels.alertname }}"

      
  
  grafana:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom grafana: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: permissive-network-cr
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: grafana

  kubeStateMetrics:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom kube-state-metrics: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: kube-state-metrics
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: kube-state-metrics
    timeIntervalPodHealth: 10m
  
  nodeExporter:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom node-exporter: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: node-exporter
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: node-exporter
  
  prometheusAdapter:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom prometheus-adapter: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: prometheus-adapter
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: prometheus-adapter

  prometheusK8s:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom prometheus-k8s: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: prometheus-k8s
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: prometheus-k8s


  prometheusOperator:
    #rbacEnabled,clusterRole,serviceAccountName configuration for pod-kube_prom prometheus-operator: These configuration is used to create the rolebinding and serviceaccount.
    #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
    #clusterRole configuration is used to configure the clusterrole in rolebinding.
    rbacEnabled: true
    clusterRole: prometheus-operator
    #serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountName: prometheus-operator

