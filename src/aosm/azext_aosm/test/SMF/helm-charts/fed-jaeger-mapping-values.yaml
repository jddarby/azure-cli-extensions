global:

  #dafault rbac clusterrole and serviceaccount configuration
  defaultRbacEnabled: true
  defaultClusterRole: permissive-network-cr
  defaultServiceAccountName: fed-jaeger-serviceaccount

  podPriorityEnabled: true

  #Generic password for all PAAS components
  adminPassword: ""

  # NetworkPolicy Configuration
  ingressNetworkPolicy:
    # enabled: true -> enables networkpolicy in federation, false -> disables networkpolicy in federation
    enabled: true
    # Namespaces which are required to be allowed for ingress traffic
    ingressTrafficNamespaces:
    - fed-service-reg
    - fed-db-etcd
    - fed-istio
    - fed-elastic
    - fed-prometheus


  # Prometheus metrics scrape intrval. Default value set to 1m.
  metricsScrapeInterval: 1m

  vault:
    enabled: false
    hashicorpVault:
      enabled: true
      service: "http://fed-vault-svc-internal.fed-vault:8200" # DevSkim: ignore DS137138
    azureKeyVault:
      enabled: false

  # Fluentd Configurations
  logging:
    enabled: false
    fluentd:
      buffer:
        bufferLimit: 512m  # Total buffer size. Maximum amount of buffer space each fluentd thread would use to keep logs. After this is exhaused, fluentd would start deleting oldest logs to make room for new logs.
        retryWait: 180s    # Interval(seconds) at which the buffer flush is retried in case of failure.
        maxRetries: 10     # Max number of retries to flush a buffer chunk. After this is exhausted, fluentd would delete the chunk.
    elastic:
      IP: ""
      Port: 9200
    enableAddlTargets: false
    addlTargets:
    - forward:
        name: fluentd
        host: ""
        port: 24224

  grafana:
    enabled: true
    # If Grafana is enabled, please add a valid Grafana server URL as per the following guidelines.
    # If Grafana is deployed WITHOUT TLS: "http://[grafana-ip]:[grafana-port]" OR "http://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    # If Grafana is deployed WITH TLS: "https://[grafana-ip]:[grafana-port]" OR "https://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    url: ""
    prometheusinfo:
      url: "http://prometheus.fed-prometheus:9090" # DevSkim: ignore DS137138

  # PaaS Registry Selector
  registry:
    docker:
      repoPath: "a4oprodaf.a4opacketcore.microsoft.com/rel_build_docker"

  # Environment variables
  envVars:
    fedType:        "paas"
    fedUniqueName:  "jaeger-default"

  # PaaS Monitoring Selector
  monitoring:
    prometheus:
      enabled: true

  # PaaS Service Mesh Selector
  mesh:
    istio:
      # set this value only if load balancer sharing key is configured. Otherwise LB will auto assign LB IP from LB IP pool.
      ingressGwIP: ""
      ingressGwFQDN: "jaeger.com"
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"

      # If specified this port will be used irresepective of TLS mode
      # If not specified, port 80 will be used if TLS is enabled, else port 443 will be used
      ingressGwPort: 16686
   
      # This controls use of TLS in GWs
      ingressGwTLS:
          enabled: true
          # Set the tls mode
            # SIMPLE --> to enable only TLS
            # MUTUAL --> to enable mTLS (default)
          mode: SIMPLE
          certManager:
            enabled: true
            certDuration: 10h
            renewBefore: 1h
            organization: affirmednetworks
            issuerName: affirmed-clusterissuer
          userProvided:
            enabled: false
            #Please refer to userguide documentation
            cacert: |-
              
            tlscrt: |-

            tlskey: |- 

      ingressGwAdditionalServices:
        - ingressGwIP: ""
          ingressGwFQDN: "keycloak.com"
          ingressGw: "keycloak-ingress"
          ingressSvcLabel: "keycloak"
          ingressGwPort: 8088
          mtlsEnabled: false
          ingressGwTLS:
            enabled: true
            mode: SIMPLE
          serviceAnnotations:
            service.beta.kubernetes.io/azure-load-balancer-internal: "true"
            service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"
      # sharing key is for having single loadbalancer IP shared among multiple paas components.
      loadBalancerSharingKey: "paas"

  # List of IP ranges that are allowed to access the load balancer (if supported)
  loadBalancerSourceRanges: "" 

  overrides:
    preDeleteEnabled:   false
    postInstallEnabled: false

pod-istio_gw:
  egressGateway:
    enabled: false

pod-jaeger:
  storage:
    type: elasticsearch
    elasticsearch:
      scheme: http
      host: ""
      port: 9200
      # Default elastic shard and replica configuration for jaeger created indices.
      # This configuration applies to every elasticsearch index jaeger creates.
      # Shards:  Buckets which Elasticsearch maintains per index. Default values is 5
      #          More shards are better for greater distribution, faster indexing and searching data, but with some maintenance overhead.
      # Replica: Duplicate index/data/shard maintained by Elasticsearch for HA and redundancy.          
      #           A values of 1 means, ES would maintain 1 duplicate copy of the data in a different node (need to have sufficient data nodes).
      #           This comes with the storage tradeoff as double storage is needed to maintain the duplicate copy.
      #           The storage size of the data nodes in fed-elastic values file must be changed accordingly, if this value is changed.
      shards: "5"
      replicas: "1"

  # rbacEnabled, serviceAccountName configuration for jaeger_collector and jaeger_query : This configuration is used to create custom clusterolebinding and serviceaccount.
  # Configuring rbacEnabled to true will create custom clusterrole, clusterrolebinding. Configuring rbacEnabled to false, clusterrole, clusterrolebinding will not be created.
  rbacEnabled: true
  # serviceAccountName configuration is used to create serviceaccount per pod.
  serviceAccountNameCollector: "jaeger-collector-sa"
  serviceAccountNameQuery: "jaeger-query-sa"

  readinessProbe:
    failureThreshold: 10
    initialDelaySeconds: 60
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 30
  livenessProbe:
    failureThreshold: 10
    initialDelaySeconds: 60
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 30



  #### On deployment of collector and query please change enabled to true and change exposedExternalIP and other reuired parameters
  collector:
    enabled: true
    replicaCount: 1
    log:
      level: info
    service:
      exposedExternalIP: 1.1.1.1
      #tchannelPort: used by jaeger-agent to send spans in jaeger.thrift format
      tchannelPort: 14267
      # If you want to enable metal lb loadbalancer change loadbalancer enabled to true
      loadBalancer:
        enabled: true
        # Provide load balancer IP, if not set metal lb will auto assign IP
        loadBalancerIP: ""
        # Provide load balancer FQDN
        loadBalancerFQDN: ""
        # sharing key is for having single loadbalancer IP shared among multiple paas components.
        loadBalancerSharingKey: "paas"

        serviceAnnotations:
          service.beta.kubernetes.io/azure-load-balancer-internal: "true"
          service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"
    resources:
      requests:
        cpu: 500m
        memory: 1Gi

 
  #### On deployment of collector and query please change enabled to true and change exposedExternalIP and other reuired parameters
  query:
    enabled: true
    replicaCount: 1
    service:
      #queryPort: externally accessible port for UI and API
      queryPort: 16686
      loadBalancer:
        enabled: false
        loadBalancerIP: ""
        loadBalancerFQDN: ""
        # sharing key is for having single loadbalancer IP shared among multiple paas components.
        loadBalancerSharingKey: "paas"
        serviceAnnotations:
          service.beta.kubernetes.io/azure-load-balancer-internal: "true"
          service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"
    resources:
      requests:
        cpu: 256m
        memory: 128Mi


  keycloak:
    enabled: true
    service:
      annotations: {}
      loadBalancer:
        enabled: false
        loadBalancerIP: ""
        loadBalancerFQDN: ""
        loadBalancerSharingKey: "paas"
        serviceAnnotations:
          service.beta.kubernetes.io/azure-load-balancer-internal: "true"
          service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"

