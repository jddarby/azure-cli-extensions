global:
  # RBAC dafault configuration per namespace: These configuration is used to create the clusterrolebinding and serviceaccount. 
  # clusterrole and PSP for is created as a part of fed-rbac. clusterrole options are restricted-cr, permissive-network-cr, permissive-full-cr
  # Configuring defaultRbacEnabled to true will create clusterrolebinding. Configuring defaultRbacEnabled to false, clusterrolebinding will not be created. 
  # defaultClusterRole configuration is to configure the clusterrole in clusterrolebinding.
  defaultRbacEnabled: true
  defaultClusterRole: permissive-network-cr
  # serviceaccount will be created by default. defaultServiceAccountName configuration is used to create default serviceaccount per namespace.
  defaultServiceAccountName: fed-smf-serviceaccount

  # If running on OCP cluster, please set "enableSCC" to "true"
  enableSCC: false
  
  podPriorityEnabled: true

  # This enables creation of specific kargo-default-profile for fed-smf 
  kargoProfileTag: "smf"

  # NetworkPolicy Configuration
  ingressNetworkPolicy:
    # enabled: true -> enables networkpolicy in federation, false -> disables networkpolicy in federation
    enabled: true
    # Namespaces which are required to be allowed for ingress traffic
    ingressTrafficNamespaces:
    - fed-service-reg
    - fed-db-etcd
    - fed-paas-helpers
    - fed-istio
    - fed-prometheus
    - fed-smf-test
    - fed-upf-sim
    - fed-upf-sim2
    - fed-upf-sim3
    - fed-timer

  # Definition of pod topology spread constraints
  # to uniformly spread all the pods across all the
  # K8s worker nodes.
  topologySpreadConstraints:
    enabled: true
    constraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway

  # UDSF DBClient FQDN/PORT configuration
  udsf:
    monitoringEnabled: true
    server:
      host: "redis-cluster.fed-redis-cluster.svc.cluster.local"
      port: "6379"

  # GeoRedundant (set-scope) timer configuration
  timerGR:
    monitoringEnabled: false

  # PaaS Tab-DB Selector
  tabdb:
    etcd:
      name: "etcd-server"
      svc: "etcd-cluster-client.fed-db-etcd.svc.cluster.local"
      port: "2379"
      targetPort: "31869"

  # to enable Pod Disruption Budgets
  enablePdbs: true

  # PaaS Fileserver Selector
  fileserver:
    ui:
      loadBalancerIP: ""
      loadBalancerPort: "85"
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.oam-lb-subnet}"

    nfs:
      remoteHost: "{deployParameters.nfs-server}"
      remotePath: "{deployParameters.nfs-filepath}"
      remotePort: "85"

    cephfs:
      enabled: false

  # PaaS Name and port numbers of the primary ingress gateway that is part of
  # this fed
  mesh:
    istio:
      ingressGw: "ingress-gateway"
      ingressGwIP: "{deployParameters.smf-ingress-gw-lb-ip}"
      ingressGwFQDN: "smf.com"
      ingressGwMaxConcurrentStreams: 1536
      ingressGwInitialStreamWindowSize: 262144
      mtlsEnabled: false
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.gn-lb-subnet}"
      # values for LI ingress gateway
      ingressGwLi:
        ingressGw: "ingress-gateway-li"
        ingressGwIP: "{deployParameters.smf-ingress-gw-li-lb-ip}"
        ingressGwFQDN: "smfli.com"
        ingressGwHttpPort: ""
        ingressGwHttpsPort: ""
        mtlsEnabled: false
        ingressGwLiMaxConcurrentStreams: 1536
        ingressGwInitialStreamWindowSize: 262144
        ingressInitialProtocol: "https"
        serviceAnnotations:
          service.beta.kubernetes.io/azure-load-balancer-internal: "true"
          service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.li-lb-subnet}"
        # SNI to be used when ingress server host multiple domains
        # each with different certificate
        ingressMultiSNI:
          enabled: false
          host:
          - name: smf.litest.com

      #Configuration for user provided certificates for ingress and egress pod-istio-gw-li pods.
      ingressGwTLSLi:
        enabled: false
        # Set the tls mode
          # SIMPLE --> to enable only TLS
          # MUTUAL --> to enable mTLS (default)
        mode: MUTUAL
        userProvided:
          enabled: false
          cacert: |-
            
          tlscrt: |-
            
          tlskey: |-

      egressGwTLSLi:
        enabled: false
        # Set the tls and mtls mode
          # SIMPLE --> to enable only TLS
          # MUTUAL --> to enable mTLS (default)
        mode: MUTUAL
        userProvided:
          enabled: false
          cacert: |-
            
          tlscrt: |-
            
          tlskey: |-

    filter:
      enabled: true
      name: "smfcc-filter-plugin"
      mountPath: "/etc/filters"
  # PaaS Monitoring Selector
  monitoring:
    prometheus:
      enabled: true
      namespace: "fed-prometheus"

  # Prometheus metrics scrape intrval. Default value set to 1m.
  metricsScrapeInterval: 30s

  # Grafana Pointer
  grafana:
    enabled: true
    # If Grafana is enabled, please add a valid Grafana server URL as per the following guidelines.
    # If Grafana is deployed WITHOUT TLS: "http://[grafana-ip]:[grafana-port]" OR "http://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    # If Grafana is deployed WITH TLS: "https://[grafana-ip]:[grafana-port]" OR "https://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    url: "{deployParameters.grafana-url}"
    prometheusinfo:
      url: "http://prometheus.fed-prometheus:9090"

  # PaaS Tracing Selector
  #tracing:
  #  jaegerAgent:

  # PaaS Logging Selector - Fluentd
  logging:
    enabled: false
    fluentd:
      buffer:
        bufferLimit: 32m  # Total buffer size. Maximum amount of buffer space each fluentd thread would use to keep logs. After this is exhaused, fluentd would start deleting oldest logs to make room for new logs.
        retryWait: 10s    # Interval(seconds) at which the buffer flush is retried in case of failure.
        maxRetries: 1     # Max number of retries to flush a buffer chunk. After this is exhausted, fluentd would delete the chunk.
    elastic:
      IP: "{deployParameters.elasticsearch-host}"
      Port: 9200
    enableAddlTargets: false
    addlTargets:
    - forward:
        name: fluentd
        host: "{deployParameters.fluentd-targets-host}"
        port: 24224
    alerts:
      enabled: false
      host: ""
      port: 3030
      realert:
        minutes: 1

      # Multiple receivers can be configured under the below receivers section. For example: if another slack reciever is to be configured, 
      # then add another list item for slack by following the syntax as shown below. Currently 3 types of receivers are supported i.e slack, email and HTTP POST.
     
      receivers:
        - slack:
            webhookurl: ""
        - post:
            http_post_url: ""
        - email:
            to_address: ""
            smtp_host: ""
            smtp_port: ""
            smtp_ssl: false
            from_addr: ""  

  # PaaS Registry Selector
  registry:
    docker:
      repoPath:       "a4oprodaf.a4opacketcore.microsoft.com/rel_build_docker"

  # PaaS Licensing server Selector
  license:
    flexera:
      remoteHost: "{deployParameters.license-host}"
      remotePort: "{deployParameters.license-port}"
      enabled: false

  # Environment variables
  envVars:
    fedType:                  "smf"
    fedUniqueName:            "{deployParameters.smf-unique-name}"
    serviceRegistryNamespace: "fed-service-reg"
    encryptPaasDataForLI: true
    configDataEncryptionEnable: false 
  

  encryptDecyptKey:
    enabled: true
    key: "afct89Ibno"

  encryptConfigKey:
    enabled: true
    key: "qrdi86Lghm"

  #loadBalancerSourceRanges var for specifying source addresses for security groups when deploying on third-party platforms
  loadBalancerSourceRanges: "[]"

  # Enable/Disable External chf server functionality
  enableExternalChfInterface: true

  # Enable/Disable local CDR generation functionality
  enableLocalCdrsInterface: false

  # Enable/Disable Gtpcagent
  enableGtpcAgent: true

  # top level flag to enable/disable lb external service
  externalLBSvc: 
    enabled: true
    configs:
       worker-connections: "20000"
       #This need to be tweaked if the number of threads
       #Not scaling up automatically
       #Below need to be changed if we are changing port range
       #GTPC is in range of 3000 - 4000, 5000 - 6000 will disable interception
       worker-processes: "16"
       gtpc_port: "5000 6000"
       pfcp_port: "7000 10000"

  # enable/disable udp lb external service
  externalLB:
    pfcp_udp_svc :
      enabled: false   #Enable this flag true when PFCP traffic via pod-nginx, else keep false for backward compatibility(i.e pfcp-external).
      #enabled: true   #Enable this flag true when PFCP traffic via pod-nginx, else keep false for backward compatibility(i.e pfcp-external).
      #Configure in batch mode
      #Max Req/Rsp pair before reusing, configured batch number is number of req sent to a single pod
      #Before triggering request towards the other pod
      #this Sessio TooLess will block future transaction. Too high will not load distribute.
      transportConfig:
        udpRequests:  1
        udpResponses: 1
        nextUpstream: true
        nextUpstreamTimeout: 20s
        nextUpstreamTries: 1
      loadBalancingMethod: "hash ${pfcp} consistent"
      configs:
        timeout: "60s"
    gtpc_udp_svc :
      enabled: true
      #Configure in batch mode
      #Max Req/Rsp pair before reusing, configured batch number is number of req sent to a single pod
      #Before triggering request towards the other pod
      #this Sessio TooLess will block future transaction. Too high will not load distribute.
      transportConfig:
        udpRequests:  10
        udpResponses: 1
        nextUpstream: true
        nextUpstreamTimeout: 20s
        nextUpstreamTries: 1
      loadBalancingMethod: ""
      configs:
        timeout: "60s"


# each interface level control, note not under externalLB section.
  externalGtpcSvc:
    - enabled: true
      name: "{deployParameters.gtpc-agent-ext-svc-name}"
      loadBalancerIP: "{deployParameters.gtpc-agent-lb-ip}"
      loadBalancerFQDN: "s5-s8-s2a-s2b-pgw.com"
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.gn-lb-subnet}"
      type:
        - "{deployParameters.gtpc-agent-ext-svc-type}"
# each interface level control, note not under externalLB section.
  externalPfcpSvc:
    - enabled: true
      name: "{deployParameters.pfcp-ext-svc-name}"
      loadBalancerIP: "{deployParameters.pfcp-lb-ip}"
      loadBalancerFQDN: ""
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-enable-high-availability-ports: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.n4-lb-subnet}"
      type:
        - "{deployParameters.pfcp-ext-svc-type}"

  # Enable/Disable LI-X1
  enableLIX1: true

  # Enable/Disable LI-X2
  enableLIX2: true

  #Enable/Disable Nchf interface usage replay functionality
  enableNchfUsageReplay: true

  # Enable/Disable Liveness Probe
  enableLivenessProbe: true

  resource:
    defaultlimit:
      cpu: 8
      memory: "3Gi"
    defaultrequest:
      cpu: 10m
      memory: "10Mi"

# PaaS Fileserver Selector/Microservice
pod-fileserver:
  enabled: true
  deployment:
    replicas: 1
  pvc:
    web:
      requestsStorage: "5Gi"
      storageClassName: "web"
    cfg:
      requestsStorage: "5Gi"
      storageClassName: "cfg"

# Config Manager Microservice
pod-cfgmgr:
  enabled: true
  confd:
    aes256cfb128Key: ""
  # rbacEnabled,clusterRole,serviceAccountName configuration for pod-cfgmgr: These configuration is used to create the clusterrolebinding and serviceaccount.
  # clusterrole and PSP for is created as a part of fed-rbac. clusterrole options are restricted-cr, permissive-network-cr, permissive-full-cr
  # Configuring rbacEnabled to true will create clusterrolebinding. Configuring rbacEnabled to false, clusterrolebinding will not be created. 
  # clusterRole configuration is used to configure the clusterrole in clusterrolebinding.
  rbacEnabled: true
  clusterRole: "permissive-full-cr"
  # serviceAccountName configuration is used to create serviceaccount per pod.
  serviceAccountName: "cfgmgr-serviceaccount"

  deployment:
    replicas: 1
  service:    
    loadBalancerIP: "{deployParameters.smf-cfgmgr-lb-ip}"
    loadBalancerFQDN: ""
    serviceAnnotations:
      service.beta.kubernetes.io/azure-load-balancer-internal: "true"
      service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.oam-lb-subnet}"
  cfgmgrFQDN: "cfgmgr.com"
  certManager:
    enabled: true
    certDuration: 10h
    renewBefore: 1h
    organization: affirmednetworks
    issuerName: affirmed-clusterissuer
  userProvided:
    enabled: false
    cacert: |-

    tlscrt: |-

    tlskey: |-

  security:
    tacacs_protocol: ""
    tacacs_service: ""
    enable_tacacs_accounting: ""
    tacacs_servers:
    - auth_timeout: ""
      auth_type: ""
      ip_address: ""
      key: ""
      port: ""
  tlscipherSuite:
    enabled: true
    # Set the cipherSuiteString for TLS that terminates the RESTCONF interface on the cfgmr pod confd process.
    # The ciphers are colon delimited, and this set in this yaml file is the full set of 5 supported by confd. An operator
    # can easily remove entries to remove any considered weak. This string will replace the entire string in the config
    # file at cfgmgr pod startup time. It is not a merge, it's an overwrite.
    cipherString: "DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA"
  sshdcipherSuite:
    enabled: true
    # Set the cipherSuiteString for sshd that terminates ssh connections (for CLI or NETCONF) on the cfgmgr pod sshd process.
    # The ciphers are comma delimited and the set in this yaml file is defaulted to the recommended 3 ciphers. An operator can
    # easily remove entries to remove any considered weak. This string will replace the entire string in the config file at
    # cfgmgr pod startup time. It is not a merge, it's an overwrite.
    cipherString: "aes256-ctr,aes192-ctr,aes128-ctr"

# Istio Gw Microservice
pod-istio_gw:
  enabled: true

  # Enable/Disable RBAC
  # if RBAC is disabled then serviceAccountName needs to be provided.
  rbacEnabled: true

  istioNspace:    "fed-istio"
  podDisruptionBudget:
    minAvailable: "10%"
  ingressGateway:
    enabled: true
    ingressGatewayServiceAccountName: istio-ingressgateway-service-account
    podPriority:
      enabled: false
  egressGateway:
    enabled: true
    egressGatewayServiceAccountName: istio-egressgateway-service-account
  paasSelector:
    # FQDN or IP address of the Remote Jaeger Server
    jaegerHostName: fqdn.com

pod-istio_gw_li:
  enabled: true

  # Enable/Disable RBAC
  # if RBAC is disabled then serviceAccountName needs to be provided.
  rbacEnabled: true
  podDisruptionBudget:
    minAvailable: "10%"

  istioNspace:    "fed-istio"
  ingressGateway:
    enabled: true
    ingressGatewayLiServiceAccountName: istio-ingressgateway-li-service-account
  egressGateway:
    enabled: true
    egressGatewayLiServiceAccountName: istio-egressgateway-li-service-account
    hpa:
      enabled: true
      workerCpuRequests: 200m
      minReplicas: 1
      maxReplicas: 5
      averageUtilization: 80
  paasSelector:
  # FQDN or IP address of the Remote Jaeger Server
    jaegerHostName: fqdn.com

# NRF Agent Microservice
pod-nrf_agent:
  enabled: true
  upgrade:
    canary : false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

  podDisruptionBudget:
    minAvailable: "10%"
  deployment:
    replicas: 1
    apiServiceHost: ""
    apiServicePort: "80"

 # Horizontal Pod Autoscaler (HPA) variables - when enabled, the number of 
 # replicas are automatically scaled between the specified minReplicas and 
 # maxReplicas based on whether the CPU utilization is above or below the 
 # specified threshold percentage relative to the sum of CPU requests of all
 # containers in the pod.
  hpa:
    enabled: true
    infraCpuRequests: 380m
    workerCpuRequests: 600m
    workerCpuLimits: 1000m
    maxReplicas: 3
    minReplicas: 2
    averageUtilization: 80
  log:
    throttlerEnable: true
    throttlerMax: 10
    throttlerInterval: 60
    throttlerSwerr: 1
    startupDelay: 30

# nginx
pod-nginx:
  # rbacEnabled,clusterRole,serviceAccountName configuration for pod-cfgmgr: These configuration is used to create the clusterrolebinding and serviceaccount.
  rbacEnabled: true
  # serviceAccountName configuration is used to create serviceaccount per pod.
  serviceAccountName: "nginx-serviceaccount"
  controller:
    ingressClass: smf.nginx

# Sub Analyzer Microservice
pod-sub_analyzer:
  enabled: true
  deployment:
    replicas: 1
    apiServiceHost: "analyzer.com"
  podDisruptionBudget:
    minAvailable: "10%"
  upgrade:
    canary : false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

  # Horizontal Pod Autoscaler (HPA) variables - when enabled, the number of
  # replicas are automatically scaled between the specified minReplicas and
  # maxReplicas based on whether the CPU utilization is above or below the
  # specified threshold percentage relative to the sum of CPU requests of all
  # containers in the pod.
  hpa:
    enabled: true
    infraCpuRequests: 10m
    workerCpuRequests: 200m
    workerCpuLimits: 1000m
    maxReplicas: 5
    minReplicas: 1
    averageUtilization: 80

  log:
    throttlerEnable: true
    throttlerMax: 10
    throttlerInterval: 60
    throttlerSwerr: 1
    startupDelay: 30

# Timer Microservice
pod-timer:
  enabled: true

  cnaInfraThreadPoolSizeDbClient: "1000"

  deployment:
    replicas: 3

  # Enable this to create service account and role binding for
  # chronos operator pod. If disabled, should create custom
  # service account 'serviceAccountName' and bind the role 'role'.
  rbacEnabled: true
  role: "chronos-operator-role"
  serviceAccountName: "chronos-operator-serviceaccount"

  mesh:
    filter:
      enabled: true
      mountPath: "/etc/filters"

# PFCP Microservice
pod-pfcp_c:
  enabled: true

  deployment:
    replicas:  1
  podDisruptionBudget:
    minAvailable: "10%"

  service:
    loadBalancerIP: "{deployParameters.pfcp-c-loadbalancer-ip}"
    # If specified, this is added as an annotation to the PFCP service
    # Other applications can then query to find the FQDN through which external
    # peers can reach this application
    externalFqdn: ""
    serviceAnnotations:
      service.beta.kubernetes.io/azure-load-balancer-internal: "true"
      service.beta.kubernetes.io/azure-load-balancer-enable-high-availability-ports: "true"
      service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.gn-lb-subnet}"

  hpa:
    enabled: true
    infraCpuRequests:       10m
    workerCpuRequests: 390m
    workerCpuLimits: 1000m
    maxReplicas: 6
    minReplicas: 1
    averageUtilization: 80

  tracing:
    enabled: true
    samplerType: "probabilistic"
    samplerParam: "1.0"
    agentPort: "6831"
    logEnabled: "false"

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# Event Exposure Microservice
pod-event_exposure:
  enabled: true

  cnaInfraThreadPoolSizeDbClient: "1000"
  podDisruptionBudget:
    minAvailable: "10%"
  deployment:
    dynamicPccEnabled:   "true"
    enableSmfccDebugLogs: false
    replicas:  1

  tracing:
    enabled: true
    agentPort: "6831"
    logEnabled: "false"

  hpa:
    enabled: true
    infraCpuRequests: 10m
    kafkaCpuRequests: 10m
    workerCpuRequests: 390m
    workerCpuLimits: 1000m
    maxReplicas: 6
    minReplicas: 1
    averageUtilization: 80

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# SMFCC Microservice
pod-smfcc:
  enabled: true

  cnaInfraThreadPoolSizeDbClient: "1000"

  # The minimum number of virtual nodes to use for the hash ring.
  # Larger ring sizes result in more granular load distributions.
  # If the number of hosts in the load balancing pool is larger than the ring size,
  # each host will be assigned a single virtual node.
  consistentHashRingSize: "1048576"
  #min ring size for SEM load balancing. This may need to be fine tuned if endpoints smfcc interact varies.
  semLoadBalMinRingSize: "10240"
  podDisruptionBudget:
    minAvailable: "10%"
  deployment:
    dynamicPccEnabled:   "true"
    enableSmfccDebugLogs: false
    replicas:  1

  alert:
    minPduSesionCreateSuccessRate: 90

  hpa:
    enabled: true
    infraCpuRequests: 10m
    kafkaCpuRequests: 10m
    workerCpuRequests: 390m
    workerCpuLimits: 1000m
    maxReplicas: 6
    minReplicas: 1
    averageUtilization: 80

  tracing:
    enabled: true
    agentPort: "6831"
    logEnabled: "false"

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

  log:
    throttlerEnable: true
    throttlerMax: 10
    throttlerInterval: 60
    throttlerSwerr: 1
    throttlerStartupDelay: 30

  tagCount:
    type: estimate
    bucketSize: 18

# URM Microservice
pod-urm:
  enabled: true

  deployment:
    enableUrmLogs: false
    replicas:  1
  podDisruptionBudget:
    minAvailable: "10%"
  hpa:
    enabled: true
    infraCpuRequests: 10m
    workerCpuRequests: 390m
    workerCpuLimits: 1000m
    maxReplicas: 6
    minReplicas: 1
    averageUtilization: 80

  tracing:
    enabled: true
    samplerType: "probabilistic"
    samplerParam: "1.0"
    agentPort: "6831"
    logEnabled: "false"

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# SMF Monitor microservice
pod-smf_monitor:
  enabled: true
  gaugeUpdateInterval: 300

  deployment:
    replicas: 1

# INBAND_DATA_AGT Microservice
pod-inband_data_agt:
  enabled: true

  deployment:
    enableIdaLogs: false
    replicas:  1

  service:
    loadBalancerIP: "{deployParameters.inband-data-agent-lb-ip}"
    serviceAnnotations:
      service.beta.kubernetes.io/azure-load-balancer-internal: "true"
      service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.gn-lb-subnet}"

  hpa:
    enabled: true
    infraCpuRequests: 10m
    workerCpuRequests: 390m
    workerCpuLimits: 1000m
    maxReplicas: 3
    minReplicas: 1
    averageUtilization: 80

  tracing:
    enabled: true
    samplerType: "probabilistic"
    samplerParam: "1.0"
    agentPort: "6831"
    logEnabled: "false"

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# Charging Agent Microservice
pod-chf_agent:
  cnaInfraThreadPoolSizeDbClient: "1000"
 
  deployment:
    replicas: 1
  podDisruptionBudget:
    minAvailable: "10%"
  hpa:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    infraCpuRequests: 100m
    kafkaCpuRequests: 100m
    workerCpuRequests: 800m
    averageUtilization: 80

  tracing:
    enabled: true
    agentPort: "6831"
    logEnabled: "false"

  #Log throttle control params start
  log:
    throttlerEnable: true
    throttlerMax: 10
    throttlerInterval: 60
    throttlerSwerr: 1
    throttlerStartupDelay: 30
  #Log throttle control params end

  upgrade:
    canary : false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# Local CDR Agent Microservice
pod-cdr_agent:
  deployment:
    replicas: 1
  podDisruptionBudget:
    minAvailable: "10%"
  nfs:
    storage: "5Gi"
    storageClass: "cdr-nfs"
    lcdrPath:  "{deployParameters.lcdr-filepath}"  
    pvName: "cdr-nfs-pv"
    pvcName: "cdr-nfs-pvc"
    directory: "/user/accounting/lcdr"

  storage:
    # storage type: 'nfs', 'cephfs' or 'local'. Default: local
    # For nfs, ensure nfs associated values are set. (storeage/storageClass/lcdrpath/pvName/pvcName/directory)
    type: "local"
    # The below parameters specific to cephfs:
    storageClassName: "rook-cephfs"
    cdrStorageSize: "5Gi"
    directory: "/user/accounting/lcdr"
    pvcName: "cdr-cephfs-pvc"

  hpa:
    enabled: true
    minReplicas:  1
    maxReplicas:  5
    infraCpuRequests: 10m
    workerCpuRequests: 460m
    averageUtilization: 50

  tracing:
    enabled: false
    samplerType: "probabilistic"
    samplerParam: "1.0"
    agentPort: "6831"
    logEnabled: "false"

  upgrade:
    canary : false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# Gtpc Agent Microservice
pod-gtpc_agent:
#ilegacyLB We need to have this always set for those feds for which the externalLB is not enhanced
# When this is enabled externalSvc under pod scope will be used whereas if disabled
# it would look for externalGtpcSvc in global scope. We should refrain from modifying this knob
# Need to be disabled for supported feds { fed-smf } enabled for other feds.
  legacyLB: false

  deployment:
    replicas: 1
  podDisruptionBudget:
    minAvailable: "10%"
  hpa:
    enabled: true
    infraCpuRequests: 10m
    workerCpuRequests: 460m
    workerCpuLimits: 1000m
    maxReplicas: 3
    minReplicas: 1
    averageUtilization: 80

  tracing:
    enabled: false
    samplerType: "probabilistic"
    samplerParam: "1.0"
    agentPort: "6831"
    logEnabled: "false"

# LI X1 Microservice
pod-li_x1:
  # rbacEnabled,clusterrole,serviceAccountName configuration for pod-li-x1: These configuration is used to create the rolebinding and serviceaccount.
  # clusterrole and PSP for is created as a part of fed-rbac. clusterrole options are restricted-cr, permissive-network-cr, permissive-full-cr, permissive-li-cr
  # Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
  # clusterRole configuration is used to configure the clusterrole in rolebinding.
  rbacEnabled: true
  clusterRole: "permissive-network-cr"
  # serviceAccountName configuration is used to create serviceaccount per pod.
  serviceAccountName: "li-x1-serviceaccount"

  cnaInfraThreadPoolSizeDbClient: "1000"

  deployment:
    replicas: 1
  podDisruptionBudget:
    minAvailable: "10%"
  hpa:
    enabled: true
    infraCpuRequests: 10m
    workerCpuRequests: 460m
    workerCpuLimits: 1000m
    maxReplicas: 5
    minReplicas: 1
    averageUtilization: 80

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# LI X2 Microservice
pod-li_x2:
  # rbacEnabled,clusterrole,serviceAccountName configuration for pod-li-x2: These configuration is used to create the rolebinding and serviceaccount.
  # clusterrole and PSP for is created as a part of fed-rbac. clusterrole options are restricted-cr, permissive-network-cr, permissive-full-cr, permissive-li-cr
  # Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
  # clusterRole configuration is used to configure the clusterrole in rolebinding.
  rbacEnabled: true
  clusterRole: "permissive-network-cr"
  # serviceAccountName configuration is used to create serviceaccount per pod.
  serviceAccountName: "li-x2-serviceaccount"

  cnaInfraThreadPoolSizeDbClient: "1000"

  deployment:
    replicas: 1
  podDisruptionBudget:
    minAvailable: "10%"
  hpa:
    enabled: true
    infraCpuRequests: 10m
    workerCpuRequests: 460m
    workerCpuLimits: 1000m
    maxReplicas: 5
    minReplicas: 1
    averageUtilization: 80

  upgrade:
    canary:            false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

# Kafka Replay Agent Microservice
pod-kafka_rplay_agt:
  deployment:
    replicas: 1

  # Horizontal Pod Autoscaler (HPA) variables - when enabled, the number of replicas are
  # automatically scaled between the specified minReplicas and maxReplicas based on whether
  # the CPU utilization is above or below the specified threshold percentage relative to 
  # the sum of CPU requests of all containers in the pod.
  hpa:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    infraCpuRequests: 50m
    kafkaCpuRequests: 200m
    workerCpuRequests: 700m
    averageUtilization: 80

  tracing:
    enabled: true
    samplerType: "probabilistic"
    samplerParam: "1.0"
    agentPort: "6831"
    logEnabled: "false"

  #Log throttle control params start
  log:
    throttlerEnable: true
    throttlerMax: 10
    throttlerInterval: 60
    throttlerSwerr: 1
    throttlerStartupDelay: 30
  #Log throttle control params end

  podDisruptionBudget:
    minAvailable: "10%"

  upgrade:
    canary : false
    canaryVersWeight:  0
    stableVersWeight:  0
    stableVersion:     0.0.0
    stableInfraImage:  ""
    stableWorkerImage: ""

  # KRA will commit message if CHF servers send any of below configured cause codes
  # Ex: causecode: "400,403,404"
  # 400 bad request "cause": "INVALID PARAMETER"
  # 403 Charging Service Error e.g. "cause": "END_USER_REQUEST_DENIED"
  # 404 USER_UNKOWN
  # NOTE: Values should be comma separated without providing any space.
  commitServerRspCodeList:
    causecode: ""
