global:

  defaultRbacEnabled: true
  defaultClusterRole: permissive-network-cr
  defaultServiceAccountName: fed-prometheus-serviceaccount
  podPriorityEnabled: true
  # If running on OCP cluster, please set "enableSCC" to "true"
  enableSCC: false
  

  # This enables creation of specific kargo-default-profile for fed-prometheus 
  kargoProfileTag: "prometheus"

  # NetworkPolicy Configuration
  ingressNetworkPolicy:
    # enabled: true -> enables networkpolicy in federation, false -> disables networkpolicy in federation
    enabled: true
    # Namespaces which are required to be allowed for ingress traffic
    ingressTrafficNamespaces:
    - fed-service-reg
    - fed-db-etcd
    - fed-istio
    - fed-elastic
    - fed-grafana

  # Prometheus metrics scrape intrval. Default value set to 1m.
  metricsScrapeInterval: 1m

  #Flag to enable/disable node affinity
  deployment:
    nodeDataplaneAffinity: "false"
  
  logging:
    enabled: false
    fluentd:
      buffer:
        bufferLimit: 512m  # Total buffer size. Maximum amount of buffer space each fluentd thread would use to keep logs. After this is exhaused, fluentd would start deleting oldest logs to make room for new logs.
        retryWait: 180s    # Interval(seconds) at which the buffer flush is retried in case of failure.
        maxRetries: 10     # Max number of retries to flush a buffer chunk. After this is exhausted, fluentd would delete the chunk.
    elastic:
      IP: "{deployParameters.elasticsearch-host}"
      Port: 9200
    enableAddlTargets: false
    addlTargets:
    - forward:
        name: fluentd
        host: ""
        port: 24224
    alerts:
      enabled: false
      host: ""
      port: 3030
      realert:
        minutes: 1
      # Multiple receivers can be configured under the below receivers section. For example: if another slack reciever is to be configured,
      # then add another list item for slack by following the syntax as shown below. Currently 3 types of receivers are supported i.e slack, email and HTTP POST.
      receivers:
        - slack:
            webhookurl: ""
        - post:
            http_post_url: ""
        - email:
            to_address: ""
            smtp_host: ""
            smtp_port: ""
            smtp_ssl: false
            from_addr: ""

  mesh:
    istio:
      ingressGwIP: "{deployParameters.prometheus-lb-ip}"
      ingressGwFQDN: "prometheus.com"
      ingressSvcLabel: "prometheus"
      ingressGwPort: 9098
      mtlsEnabled: false
      ingressGwTLS:
        enabled: true
        mode: SIMPLE
        certManager:
          enabled: true
          certDuration: 10h
          renewBefore: 1h
          organization: affirmednetworks
          issuerName: affirmed-clusterissuer
        userProvided:
          enabled: false
          #Please refer to userguide documentation
          cacert: |-
          tlscrt: |-
          tlskey: |-

      ingressGwAdditionalServices:
        - ingressGwIP: ""
          ingressGwFQDN: "alertmanager.com"
          ingressGw: "alertmanager-ingress"
          ingressSvcLabel: "alertmanager"
          ingressGwPort: 9091
          mtlsEnabled: false
          ingressGwTLS:
            enabled: true
            mode: SIMPLE
          serviceAnnotations:
            service.beta.kubernetes.io/azure-load-balancer-internal: "true"
            service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.oam-lb-subnet}"
        - ingressGwIP: ""
          ingressGwFQDN: "thanos.com"
          ingressGw: "thanos-ingress"
          ingressSvcLabel: "thanos"
          ingressGwPort: 9090
          mtlsEnabled: false
          ingressGwTLS:
            enabled: true
            mode: SIMPLE
          serviceAnnotations:
            service.beta.kubernetes.io/azure-load-balancer-internal: "true"
            service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "{deployParameters.oam-lb-subnet}"

      loadBalancerSharingKey: "paas"
      serviceAnnotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
        service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "none"



  grafana:
    enabled: true
    # If Grafana is enabled, please add a valid Grafana server URL as per the following guidelines.
    # If Grafana is deployed WITHOUT TLS: "http://[grafana-ip]:[grafana-port]" OR "http://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    # If Grafana is deployed WITH TLS: "https://[grafana-ip]:[grafana-port]" OR "https://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    url: "{deployParameters.grafana-url}"
    prometheusinfo:
      url: "http://prometheus.fed-prometheus:9090"

  monitoring:
    prometheus:
      enabled: true

  # PaaS Registry Selector 
  registry:
    docker:
      repoPath: "a4oprodaf.a4opacketcore.microsoft.com/rel_build_docker"

  envVars:
    fedType:        "paas"
    fedUniqueName:  "{deployParameters.prometheus-unique-name}"


  loadBalancerSourceRanges: ""

  overrides:
    preDeleteEnabled:   false
    postInstallEnabled: false

pod-istio_gw:
  enabled: true

  # Enable/Disable RBAC
  # if RBAC is disabled then serviceAccountName needs to be provided.
  rbacEnabled: true

  istioNspace:    "fed-istio"

  ingressGateway:
    enabled: true
    ingressGatewayServiceAccountName: istio-ingressgateway-service-account
  egressGateway:
    enabled: false
    egressGatewayServiceAccountName: istio-egressgateway-service-account
  paasSelector:
    # FQDN or IP address of the Remote Jaeger Server
    jaegerHostName: "{deployParameters.istio-gw-jaeger-hostname}"

pod-prometheus:

    # rbacEnabled, serviceAccountName configuration for pod-prometheus: These configuration is used to create the psp, clusterrole, clusterrolebinding and serviceaccount.
    # Configuring rbacEnabled to true will create psp, clusterrole and clusterrolebinding. Configuring rbacEnabled to false, psp, clusterrole and clusterrolebinding will not be created.
    rbacEnabled: true
    # # serviceAccountName configuration is used to create serviceaccount per pod.
    serviceAccountNameOperator: "prometheus-operator-serviceaccount"
    serviceAccountNamePrometheus: "prometheus-serviceaccount"
    serviceAccountNameAlertmanager: "alertmanager-serviceaccount"
    serviceAccountNameThanos: "thanos-serviceaccount"

    config:
      global:
        resolve_timeout: 5m
      route:
        group_wait: 30s
        group_interval: 2m
        repeat_interval: 2m
        receiver: "null" # Default receiver. Provide receiver name to send alerts to, slackreceiver for slack, emailreceiver for email, postreceiver for HTTP POST

        # Multiple receiver can be enabled by uncommenting routes section. Provide receiver names in below format to send alerts to multiple receivers. For more details visit multiple receivers section in http://confluence.affirmednetworks.com/pages/viewpage.action?pageId=10037337
        #routes:
        #  - receiver: "postreceiver"
        #    continue: true
        #  - receiver: "emailreceiver"
        #    continue: true
      receivers:
      - name: "null"
      - name: "postreceiver"
        webhook_configs:  #HTTP POST receiver
        - url: "http://XXXX"
          http_config:
            tls_config:
              insecure_skip_verify: true

      - name: "emailreceiver"
        email_configs:    #email receiver
        - to: "user1@example.com"
          from: "user2@example.com"
          smarthost: "XXXX:80"  #SMTP IP address along with port
          auth_username: "user@example.com" #SMTP authentication username and password
          auth_password: "password"
          require_tls: false
          headers: {Subject: "Alert from: {{ .CommonLabels.alertname }} "}

      - name: "slackreceiver" 
        slack_configs:     #slack receiver
        - channel: "#channel_name"
          api_url: "http://XXXX"
          text: "summary: {{ .CommonAnnotations.summary }}\ndescription: {{ .CommonAnnotations.description }}"
          title: "Alert from: {{ .CommonLabels.alertname }}"


    # Prometheus Instance Selector - Prometheus operator manages selected prometheus instances, if we set this flag to false then Prometheus operator manages all running prometheus instances in the cluster. 
    # If it is true then it manages only selected Prometheus instances.
    promInstanceSelector: false
    name: prometheus
    alertmanagerName: prometheus-alerts

    serviceMonitor:
      istioNamespace: "fed-istio"

    prometheus:
      storage:
        # type can be local, remote or rook
        type: "{deployParameters.storage-type}"

        # To use storage class of fed-rook-ceph, Configure storageclass field with the storage class name that gets deployed with fed-rook-ceph.
        # default value is "rook-cephbp". To use any other storage provisioner provide name of your convienence. 
        storageClassName: rook-cephbp
        # if storage.type is set as rook, Configure storageclass and do not configure the below mentioned fields. When type is rook, provisioner and all the other 
        # configuration parameters will be taken from storage class of fed-rook-ceph.
        # set provisioner as:
        # kubernetes.io/cinder for cinder storage
        # kubernetes.io/azure-disk for azureDisk
        # To provide any other custom storage, configure provisioner field and add related parameters under customParameters
        provisioner: kubernetes.io/cinder

        parameters:
          cinder:
            type: sannimbf300
            availability: nova
            fsType: ext4
          azureDisk:
            storageaccounttype: ""
            kind: ""
          #configure below customParameters to provide parameters for custom storage option, if the provisioner is none of the above.  
          customParameters: {}

        #PersistentVolumes that are dynamically created by a StorageClass will have the reclaim policy specified in the reclaimPolicy field of the class, which can be either Delete or Retain
        reclaimPolicy: Delete
        allowVolumeExpansion: true
        
        resource:
          request: 100Gi # if external storage is enabled then resource request has to be configured as per user/customer requirement
      retention: 3d

      # Prometheus can be configured to read from and write to remote storage, in addition to its local time series database. If it is enabled then provide write and read URL's.
      remoteStorage:
        enabled: false
        # remote write url Ex. http://localhost:8086/api/v1/prom/write?db=prometheus
        remoteWriteUrl: ""
        # Timeout for requests to the remote write endpoint.
        remoteWriteTimeout: 30s
        # remote read url Ex. http://localhost:8086/api/v1/prom/read?db=prometheus
        remoteReadUrl: ""

      enableAdminAPI: false
      resources:
        limits:
          cpu: "10"
          memory: 24Gi
        requests:
          cpu: "1"
          memory: 4Gi

    thanosQuery:
      name: thanos-query
      deploy:
        logLevel: "info"
        resources:
          requests:
            cpu: "1"
            memory: 4Gi
          limits:
            cpu: "4"
            memory: 4Gi

      service:
        externalIpAddress: "1.1.1.1"
      hpa:
       enabled: true
       minReplicas: 3
       maxReplicas: 6
      
    thanos:
      enabled: true
      longTermStorage:
        # Chnage it true if long term storage is required. Make sure to provide valid configuration after enabling longTermStorage.
        enabled: false
        # Long term storage supported with type AZURE, S3, GCS. Currently we have tested with AZURE
        type: AZURE
        # Config is different for differnt storage types, so the below conig is for AZURE storage account. 
        # Make sure to create storage account in azure and provide all parameters with valid details otherwise thanos sidecar will get fail and goes to crashloopbackoff if it is not able to connect to storage.
        # For other storages refer to https://thanos.io/v0.24/thanos/storage.md/
        # Example Config
        # config:
        #    storage_account: "set_storage_account_name"
        #    storage_account_key: "set_key_sIH9XPU7czs66l7PCC8O0YrcsPo2ys0bQ3MBPD4AVHj6+VApHIYz49Cx8BsqwOmamfBq9y5q6Oh5cEI9b2rw=="
        #    container: "set_container_name"
        config:
          storage_account: ""
          storage_account_key: ""
          container: ""


    probesCheck:
      liveliness:
        failureThreshold: 120
        initialDelaySeconds: 30
        periodSeconds: 60
        successThreshold: 1
        timeoutSeconds: 5
      
      readiness:
        failureThreshold: 120
        initialDelaySeconds: 30
        periodSeconds: 60
        successThreshold: 1
        timeoutSeconds: 5
        
    # HTTP/Network failure alerts threshold value configuration
    httpAlertsThreshold:
      istio5xxErrorPercentage: 25
      istio4xxErrorPercentage: 25
      istioReqLatencySeconds: 5
      httpSrvr5xxErrorPercentage: 25
      httpSrvr4xxErrorPercentage: 50
      httpClientRespRcvd5xxErrorPercentage: 25
      httpClientRespRcvd460N499ErrorPercentage: 25
      httpSrvrReqRate: 500
      firingActiveAlertInterval: 2m
