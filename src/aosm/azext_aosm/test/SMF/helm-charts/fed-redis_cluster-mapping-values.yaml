global:
  registry:
    docker:
      repoPath: "a4oprodaf.a4opacketcore.microsoft.com/rel_build_docker"
      #Create a docker-registry secret in the same namespace as the chart and provide the name here
      imagePullSecret: ""

  # Environment variables
  envVars:
    fedType: "paas"     
    fedUniqueName: "{deployParameters.redis-cluster-unique-name}"
 
  topologySpreadConstraints:
    enabled: true
    constraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway

  monitoring:
    prometheus:
      enabled: true

  # This enables creation of specific kargo-default-profile for fed-redis-cluster 
  kargoProfileTag: "redis"
    
  grafana:
    enabled: true
    # If Grafana is enabled, please add a valid Grafana server URL as per the following guidelines.
    # If Grafana is deployed WITHOUT TLS: "http://[grafana-ip]:[grafana-port]" OR "http://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    # If Grafana is deployed WITH TLS: "https://[grafana-ip]:[grafana-port]" OR "https://[paas-lb-ip]:[grafana-port]" (by-default grafana-port is 3000)
    url: "{deployParameters.grafana-url}"
    prometheusinfo:
      url: "http://prometheus.fed-prometheus:9090"
  
  logging:
    enabled: false
    fluentd:
      buffer:
        bufferLimit: 512m  # Total buffer size. Maximum amount of buffer space each fluentd thread would use to keep logs. After this is exhaused, fluentd would start deleting oldest logs to make room for new logs.
        retryWait: 180s    # Interval(seconds) at which the buffer flush is retried in case of failure.
        maxRetries: 10     # Max number of retries to flush a buffer chunk. After this is exhausted, fluentd would delete the chunk.
    elastic:
      IP: "{deployParameters.elasticsearch-host}"
      Port: 9200
    enableAddlTargets: false
    addlTargets:
    - forward:
        name: fluentd
        host: ""
        port: 24224
    alerts:
      enabled: false
      host: ""
      port: 3030
      realert:
        minutes: 1

      # Multiple receivers can be configured under the below receivers section. For example: if another slack receiver is to be configured,
      # then add another list item for slack by following the syntax as shown below. Currently 3 types of receivers are supported i.e slack, email and HTTP POST.

      receivers:
      - email:
         to_address: ""
         smtp_host: ""
         smtp_port: ""
         smtp_ssl: false
         from_addr: ""

  #RBAC dafault configuration per namespace: These configuration is used to create the clusterrolebinding and serviceaccount
  defaultRbacEnabled: true
  #Flag to enable/disable pod priority.
  podPriorityEnabled: true

pod-redis_cluster:
  overrideEnabled: true #Keep this as false if more than 1 redis clusters need to be installed in one k8s cluster
  nameOverride: "node-for-redis"
  fullnameOverride: "node-for-redis"
  numberOfPrimaries: 3
  replicationFactor: 2
  imagePullPolicy: IfNotPresent
  prometheus:
    enabled: true
  #rbacEnabled,clusterRole,serviceAccountName configuration for pod-redis_cluster: These configuration is used to create the rolebinding and serviceaccount.
  #Configuring rbacEnabled to true will create rolebinding. Configuring rbacEnabled to false, rolebinding will not be created. 
  #clusterRole configuration is used to configure the clusterrole in rolebinding.
  rbacEnabled: true
  #serviceAccountName configuration is used to create serviceaccount per pod.
  serviceAccount:
    name: "node-for-redis"
  ## Resource limits
  resources:
    limits:
      cpu: "1"
      memory: "4Gi"
    requests:
      cpu: "1"
      memory: "4Gi"

  metrics:
    enabled: true

  redis:
    configuration:
      # You can provide the path of a redis configuration file that will be added in a configMap and included
      # in the redis-server configuration in each redis-cluster node.
      # The file must be local to the helm chart (in the chart folder).
      file: ""
      # You can provide the redis config directly as a map instead of a file as shown in the example below.
      # If BOTH the "file" and "value" are defined, the value will be used, i.e. treated as an override value.
      # Please see the redis.io docs for details on each of the fields below.
      # memory-related --> https://redis.io/topics/lru-cache
      # cluster-related --> https://redis.io/topics/cluster-tutorial
      # valueMap:
      # maxmemory-policy: "volatile-lfu"
      # maxmemory: "10Gb"
      # save: ""
      # lazyfree-lazy-eviction: "yes"
      # lazyfree-lazy-expire: "yes"
      # lazyfree-lazy-server-del: "yes"
      # replica-lazy-flush: "yes"
      # cluster-enabled: "yes"
      # cluster-require-full-coverage: "no"
      # cluster-allow-reads-when-down: "yes"
      valueMap:
        save: ""
